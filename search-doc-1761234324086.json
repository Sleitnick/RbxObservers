{"searchDocs":[{"title":"Getting Started","type":0,"sectionRef":"#","url":"/RbxObservers/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Wally Configuration​","type":1,"pageTitle":"Getting Started","url":"/RbxObservers/docs/intro#wally-configuration","content":" Once Wally is installed, run wally init on your project directory, and then add the various utility modules found here as dependencies. For example, the following could be a wally.toml file for a project that includes a few of these modules:  [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] Observers = &quot;sleitnick/observers@^0.3.3&quot;   To install, run wally install within your project. Wally will create a Package folder in your directory with the installed dependency.  ","version":"Next","tagName":"h2"},{"title":"Rojo Configuration​","type":1,"pageTitle":"Getting Started","url":"/RbxObservers/docs/intro#rojo-configuration","content":" The Package folder created by Wally should be synced into Roblox Studio through your Rojo configuration. For instance, a Rojo configuration might have the following entry to sync the Packages folder into ReplicatedStorage:  { &quot;name&quot;: &quot;rbx-util-example&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;Packages&quot;: { &quot;$path&quot;: &quot;Packages&quot; } } } }   ","version":"Next","tagName":"h2"},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"/RbxObservers/docs/intro#usage-example","content":" The Observers module can now be used in scripts, such as the following:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Observers = require(ReplicatedStorage.Packages.Observers) Observers.observeTag(&quot;SomeTag&quot;, function(instance: Instance) print(`Observing {instance}`) return function() print(`Stopped observing {instance}`) end end)   ","version":"Next","tagName":"h2"},{"title":"roblox-ts​","type":1,"pageTitle":"Getting Started","url":"/RbxObservers/docs/intro#roblox-ts","content":" For developers using roblox-ts, install the @rbxts/observers package.  npm i --save @rbxts/observers  ","version":"Next","tagName":"h2"},{"title":"Observer Pattern","type":0,"sectionRef":"#","url":"/RbxObservers/docs/observer-pattern","content":"","keywords":"","version":"Next"},{"title":"Why Lifetime is Important​","type":1,"pageTitle":"Observer Pattern","url":"/RbxObservers/docs/observer-pattern#why-lifetime-is-important","content":" The lifetime of a state is defined by the time in which is begins to the time in which it ends. This is why the observer function requires developers to return a function for cleanup. By doing so, the lifetime of a given state can be captured. For game programming, this allows developers to kick off tasks for a given task, and then easily clean up those tasks once the state has changed.  For example:  observeTag(&quot;Disco&quot;, function(part) -- Start flashing the part random colors every frame: local heartbeat = RunService.Heartbeat:Connect(function() part.Color = Color3.new(math.random(), math.random(), math.random()) end) -- Stop flashing on cleanup: return function() heartbeat:Disconnect() end end)   In the above example, the &quot;Disco&quot; tag is being observed. When the observer triggers the function, we enter the beginning of the lifecycle for part, where we know that part has the &quot;Disco&quot; tag. At this point, we can hook up our disco part by flashing it different colors every frame. Then we return a cleanup function, which will be called at the end of the lifecycle (i.e. when the Disco tag is removed or the part is destroyed). This function disconnects the heartbeat connection, thus cleaning up the operation.  ","version":"Next","tagName":"h2"},{"title":"Differences from Event-Driven Programming​","type":1,"pageTitle":"Observer Pattern","url":"/RbxObservers/docs/observer-pattern#differences-from-event-driven-programming","content":" Event-driven programming is quite similar, as we are able to observe changes to state. The key differences though is that event-driven programming does not necessarily encapsulate detecting the lifetime of a given state, nor does it necessarily capture the current state.  For instance:  part:GetPropertyChangedSignal(&quot;Color&quot;):Connect(function() ... end)   The code above will fire any time the Color property changes for part. However, the triggered function has no understanding of when the given color changes again. Also, the given function will not be triggered for the current state; only future changes will trigger the function.  ","version":"Next","tagName":"h2"},{"title":"Differences from Reactive (RX) Programming​","type":1,"pageTitle":"Observer Pattern","url":"/RbxObservers/docs/observer-pattern#differences-from-reactive-rx-programming","content":" Reactive programming cares about reacting, transforming, and consuming state. While the observer pattern is quite similar, reactive programming doesn't define the lifetime of a given state.  ","version":"Next","tagName":"h2"},{"title":"Cleanup Idempotence​","type":1,"pageTitle":"Observer Pattern","url":"/RbxObservers/docs/observer-pattern#cleanup-idempotence","content":" All cleanup functions should be idempotent. In other words, cleanup functions should be capable of being called many times without causing issues. For example, the top-level cleanup for an observer could be called multiple times, but should never cause a problem. This creates a safe environment for cleanup operations. ","version":"Next","tagName":"h2"},{"title":"Characters","type":0,"sectionRef":"#","url":"/RbxObservers/docs/Observers/characters","content":"Characters Use the observeCharacter observer to observe the lifespan of characters in the game. Observers.observeCharacter(function(player, character) -- Character was spawned print(&quot;Character spawned for &quot; .. player.Name) -- Wait for humanoid: local humanoid = character:WaitForChild(&quot;Humanoid&quot;, 60) -- Listen to humanoid Died event: local onDiedConn: RBXScriptConnection? = nil if humanoid then onDiedConn = humanoid.Died:Connect(function() print(&quot;Character died for &quot; .. player.Name) end) end return function() -- Character was removed print(&quot;Character removed for &quot; .. player.Name) if onDiedConn then onDiedConn:Disconnect() onDiedConn = nil end end end) ","keywords":"","version":"Next"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/RbxObservers/docs/Observers/attributes","content":"","keywords":"","version":"Next"},{"title":"Typing​","type":1,"pageTitle":"Attributes","url":"/RbxObservers/docs/Observers/attributes#typing","content":" Technically, the value of an attribute is not known (it's not necessarily unknown, as we know it's some sort of attribute value, of which there is a limited amount of types). However, to make the API easier to use, observeAttribute uses a generic value to allow developers to denote what type they expect. For instance, a string:  Observers.observeAttribute(myInstance, &quot;MyAttribute&quot;, function(value: string) ... end)   However, be aware that this does not enforce the attribute to be a specific type. Especially in client-facing code, it is good to ensure that the type of the attribute matches what is expected. For instance, if a string is expected:  Observers.observeAttribute(myInstance, &quot;MyAttribute&quot;, function(value: string) assert(typeof(value) == &quot;string&quot;, &quot;expected string for MyAttribute; got &quot; .. typeof(value)) ... end)   ","version":"Next","tagName":"h2"},{"title":"Guards​","type":1,"pageTitle":"Attributes","url":"/RbxObservers/docs/Observers/attributes#guards","content":" A guard is an optional predicate function that can be used to control if the observer function should be triggered for a given value. For instance, this could be used to type-check the value at runtime.  Observers.observeAttribute( myInstance, &quot;MyAttribute&quot;, function(value: string) print(&quot;value is a string&quot;, value) end, function(value: unknown) -- Guard function ensures the value is a string. -- The observer will only trigger if this returns a truthy value. return typeof(value) == &quot;string&quot; end )  ","version":"Next","tagName":"h2"},{"title":"Properties","type":0,"sectionRef":"#","url":"/RbxObservers/docs/Observers/properties","content":"Properties Observing properties on instances can be done via the observeProperty observer. Observers.observeProperty(workspace.Model, &quot;Name&quot;, function(name) print(&quot;Name is now: &quot; .. name) return function() print(&quot;Name is no longer: &quot; .. name) end end) ","keywords":"","version":"Next"},{"title":"Players","type":0,"sectionRef":"#","url":"/RbxObservers/docs/Observers/players","content":"Players The observePlayer observer can be used to observe when players enter and leave a game. Observers.observePlayer(function(player) print(player.Name .. &quot; entered game&quot;) return function() print(player.Name .. &quot; left game&quot;) end end) ","keywords":"","version":"Next"},{"title":"Observers","type":0,"sectionRef":"#","url":"/RbxObservers/api/Observers","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#functions","content":" ","version":null,"tagName":"h2"},{"title":"observeProperty​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#observeProperty","content":"&lt;/&gt; Observers.observeProperty( instance: Instance , property: string, callback: (value: unknown) → () → () ) → () → () Creates an observer around a property of a given instance. observeProperty(workspace.Model, &quot;Name&quot;, function(newName: string) print(&quot;New name:&quot;, name) return function() -- Cleanup print(&quot;Model's name is no longer:&quot;, name) end end)   ","version":null,"tagName":"h3"},{"title":"observeTag​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#observeTag","content":"&lt;/&gt; Observers.observeTag( tag: string, callback: (instance: T) → (() → ())?, ancestors: {Instance }? ) → () → () Creates an observer around a CollectionService tag. The given callback will fire for each instance that has the given tag. The callback should return a function, which will be called when the given instance's tag is either destroyed, loses the given tag, or (if the ancestors table is provided) goes outside of the allowed ancestors. The function itself returns a function that can be called to stop the observer. This will also call any cleanup functions of currently-observed instances. local stopObserver = Observers.observeTag(&quot;MyTag&quot;, function(instance: Instance) print(&quot;Observing&quot;, instance) -- The &quot;cleanup&quot; function: return function() print(&quot;Stopped observing&quot;, instance) end end) -- Optionally, the `stopObserver` function can be called to completely stop the observer: task.wait(10) stopObserver() Ancestor Inclusion List By default, the observeTag function will observe a tagged instance anywhere in the Roblox game hierarchy. The ancestors table can optionally be used, which will restrict the observer to only observe tagged instances that are descendants of instances within the ancestors table. For instance, if a tagged instance should only be observed when it is in the Workspace, the Workspace can be added to the ancestors list. This might be useful if a tagged model prefab exist somewhere such as ServerStorage, but shouldn't be observed until placed into the Workspace. local allowedAncestors = { workspace } Observers.observeTag( &quot;MyTag&quot;, function(instance: Instance) ... end, allowedAncestors )   ","version":null,"tagName":"h3"},{"title":"observeCharacter​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#observeCharacter","content":"&lt;/&gt; Observers.observeCharacter(callback: ( player: Player , character: Model ) → (() → ())?) → () → () Creates an observer that captures each character in the game. observeCharacter(function(player, character) print(&quot;Character spawned for &quot; .. player.Name) return function() -- Cleanup print(&quot;Character removed for &quot; .. player.Name) end end)   ","version":null,"tagName":"h3"},{"title":"observePlayer​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#observePlayer","content":"&lt;/&gt; Observers.observePlayer(callback: (player: Player ) → (() → ())?) → () → () Creates an observer that captures each player in the game. observePlayer(function(player) print(&quot;Player entered game&quot;, player.Name) return function() -- Cleanup print(&quot;Player left game (or observer stopped)&quot;, player.Name) end end)   ","version":null,"tagName":"h3"},{"title":"observeAttribute​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#observeAttribute","content":"&lt;/&gt; Observers.observeAttribute( instance: Instance , name: string, callback: (value: AttributeValue) → () → (), guard: ((value: AttributeValue) → boolean)? ) → () → () Creates an observer around an attribute of a given instance. The callback will fire for any non-nil attribute value. observeAttribute(workspace.Model, &quot;MyAttribute&quot;, function(value) print(&quot;MyAttribute is now:&quot;, value) return function() -- Cleanup print(&quot;MyAttribute is no longer:&quot;, value) end end) An optional guard predicate function can be supplied to further narrow which values trigger the observer. For instance, if only strings are wanted: observeAttribute( workspace.Model, &quot;MyAttribute&quot;, function(value) print(&quot;value is a string&quot;, value) end, function(value) return typeof(value) == &quot;string&quot; end ) The observer also returns a function that can be called to clean up the observer: local stopObserving = observeAttribute(workspace.Model, &quot;MyAttribute&quot;, function(value) ... end) task.wait(10) stopObserving()  ","version":null,"tagName":"h3"},{"title":"Tags","type":0,"sectionRef":"#","url":"/RbxObservers/docs/Observers/tags","content":"","keywords":"","version":"Next"},{"title":"Type-Checking​","type":1,"pageTitle":"Tags","url":"/RbxObservers/docs/Observers/tags#type-checking","content":" Note that the instance class is unknown to the observer. The above example assumes it is a Part, but that is not guaranteed. It is best to check that the type you're expecting is correct:  Observers.observeTag(&quot;Disco&quot;, function(part: BasePart) assert(part:IsA(&quot;BasePart&quot;), &quot;expected part&quot;) ... end)   ","version":"Next","tagName":"h2"},{"title":"Ancestry Inclusion List​","type":1,"pageTitle":"Tags","url":"/RbxObservers/docs/Observers/tags#ancestry-inclusion-list","content":" By default, the tag observer will observe tagged instances in all ancestors within the game.  A common desire when observing tagged instances is to only observe instances within a specific ancestor. For instance, a developer might only want to observe instances within the workspace. This can be done by supplying a list of allowed ancestors in the ancestors array parameter:  local allowedAncestors = { workspace } Observers.observeTag( &quot;Disco&quot;, function(part: BasePart) ... end, allowedAncestors )  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}