"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[583],{5136:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Observers/attributes","title":"Attributes","description":"The Attribute observer is triggered when an attribute is set to a non-nil value.","source":"@site/docs/Observers/attributes.md","sourceDirName":"Observers","slug":"/Observers/attributes","permalink":"/RbxObservers/docs/Observers/attributes","draft":false,"unlisted":false,"editUrl":"https://github.com/Sleitnick/RbxObservers/edit/main/docs/Observers/attributes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Observer Pattern","permalink":"/RbxObservers/docs/observer-pattern"},"next":{"title":"Characters","permalink":"/RbxObservers/docs/Observers/characters"}}');var s=n(4848),i=n(8453);const a={},o="Attributes",u={},c=[{value:"Typing",id:"typing",level:2},{value:"Guards",id:"guards",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"attributes",children:"Attributes"})}),"\n",(0,s.jsxs)(t.p,{children:["The Attribute observer is triggered when an attribute is set to a non-",(0,s.jsx)(t.code,{children:"nil"})," value."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'Observers.observeAttribute(myInstance, "MyAttribute", function(value)\n\tprint("Attribute is", value)\n\n\treturn function()\n\t\tprint("Attribute is no longer", value)\n\tend\nend)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"typing",children:"Typing"}),"\n",(0,s.jsxs)(t.p,{children:["Technically, the value of an attribute is not known (it's not necessarily ",(0,s.jsx)(t.code,{children:"unknown"}),", as we know it's some sort of attribute value, of which there is a limited amount of types). However, to make the API easier to use, ",(0,s.jsx)(t.code,{children:"observeAttribute"})," uses a generic value to allow developers to denote what type they expect. For instance, a string:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'Observers.observeAttribute(myInstance, "MyAttribute", function(value: string) ... end)\n'})}),"\n",(0,s.jsx)(t.p,{children:"However, be aware that this does not enforce the attribute to be a specific type. Especially in client-facing code, it is good to ensure that the type of the attribute matches what is expected. For instance, if a string is expected:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'Observers.observeAttribute(myInstance, "MyAttribute", function(value: string)\n\tassert(typeof(value) == "string", "expected string for MyAttribute; got " .. typeof(value))\n\t...\nend)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"guards",children:"Guards"}),"\n",(0,s.jsx)(t.p,{children:"A guard is an optional predicate function that can be used to control if the observer function should be triggered for a given value. For instance, this could be used to type-check the value at runtime."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'Observers.observeAttribute(\n\tmyInstance,\n\t"MyAttribute",\n\tfunction(value: string)\n\t\tprint("value is a string", value)\n\tend,\n\tfunction(value: unknown)\n\t\t-- Guard function ensures the value is a string.\n\t\t-- The observer will only trigger if this returns a truthy value.\n\t\treturn typeof(value) == "string"\n\tend\n)\n'})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(6540);const s={},i=r.createContext(s);function a(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);