"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[119],{28834:e=>{e.exports=JSON.parse('{"functions":[{"name":"observeCharacter","desc":"Creates an observer that captures each character in the game.\\n\\n```lua\\nobserveCharacter(function(player, character)\\n\\tprint(\\"Character spawned for \\" .. player.Name)\\n\\n\\treturn function()\\n\\t\\t-- Cleanup\\n\\t\\tprint(\\"Character removed for \\" .. player.Name)\\n\\tend\\nend)\\n```","params":[{"name":"callback","desc":"","lua_type":"(player: Player, character: Model) -> (() -> ())?"}],"returns":[{"desc":"","lua_type":"() -> ()\\n"}],"function_type":"static","source":{"line":21,"path":"lib/observeCharacter.lua"}},{"name":"observeProperty","desc":"Creates an observer around a property of a given instance.\\n\\n```lua\\nobserveProperty(workspace.Model, \\"Name\\", function(newName: string)\\n\\tprint(\\"New name:\\", name)\\n\\n\\treturn function()\\n\\t\\t-- Cleanup\\n\\t\\tprint(\\"Model\'s name is no longer:\\", name)\\n\\tend\\nend)\\n```","params":[{"name":"instance","desc":"","lua_type":"Instance"},{"name":"property","desc":"","lua_type":"string"},{"name":"callback","desc":"","lua_type":"(value: unknown) -> () -> ()"}],"returns":[{"desc":"","lua_type":"() -> ()\\n"}],"function_type":"static","source":{"line":19,"path":"lib/observeProperty.lua"}},{"name":"observeAttribute","desc":"Creates an observer around an attribute of a given instance. The callback will fire for any non-nil\\nattribute value.\\n\\n```lua\\nobserveAttribute(workspace.Model, \\"MyAttribute\\", function(value)\\n\\tprint(\\"MyAttribute is now:\\", value)\\n\\n\\treturn function()\\n\\t\\t-- Cleanup\\n\\t\\tprint(\\"MyAttribute is no longer:\\", value)\\n\\tend\\nend)\\n```\\n\\nAn optional `guard` predicate function can be supplied to further narrow which values trigger the observer.\\nFor instance, if only strings are wanted:\\n\\n```lua\\nobserveAttribute(\\n\\tworkspace.Model,\\n\\t\\"MyAttribute\\",\\n\\tfunction(value) print(\\"value is a string\\", value) end,\\n\\tfunction(value) return typeof(value) == \\"string\\" end\\n)\\n```\\n\\nThe observer also returns a function that can be called to clean up the observer:\\n```lua\\nlocal stopObserving = observeAttribute(workspace.Model, \\"MyAttribute\\", function(value) ... end)\\n\\ntask.wait(10)\\nstopObserving()\\n```","params":[{"name":"instance","desc":"","lua_type":"Instance"},{"name":"name","desc":"","lua_type":"string"},{"name":"callback","desc":"","lua_type":"(value: AttributeValue) -> () -> ()"},{"name":"guard","desc":"","lua_type":"((value: AttributeValue) -> boolean)?\\n"}],"returns":[{"desc":"","lua_type":"() -> ()\\n"}],"function_type":"static","source":{"line":61,"path":"lib/observeAttribute.lua"}},{"name":"observeTag","desc":"Creates an observer around a CollectionService tag. The given callback will fire for each instance\\nthat has the given tag.\\n\\nThe callback should return a function, which will be called when the given instance\'s tag is either\\ndestroyed, loses the given tag, or (if the `ancestors` table is provided) goes outside of the allowed\\nancestors.\\n\\nThe function itself returns a function that can be called to stop the observer. This will also call\\nany cleanup functions of currently-observed instances.\\n\\n```lua\\nlocal stopObserver = Observers.observeTag(\\"MyTag\\", function(instance: Instance)\\n\\tprint(\\"Observing\\", instance)\\n\\n\\t-- The \\"cleanup\\" function:\\n\\treturn function()\\n\\t\\tprint(\\"Stopped observing\\", instance)\\n\\tend\\nend)\\n\\n-- Optionally, the `stopObserver` function can be called to completely stop the observer:\\ntask.wait(10)\\nstopObserver()\\n```\\n\\n#### Ancestor Inclusion List\\nBy default, the `observeTag` function will observe a tagged instance anywhere in the Roblox game\\nhierarchy. The `ancestors` table can optionally be used, which will restrict the observer to only\\nobserve tagged instances that are descendants of instances within the `ancestors` table.\\n\\nFor instance, if a tagged instance should only be observed when it is in the Workspace, the Workspace\\ncan be added to the `ancestors` list. This might be useful if a tagged model prefab exist somewhere\\nsuch as ServerStorage, but shouldn\'t be observed until placed into the Workspace.\\n\\n```lua\\nlocal allowedAncestors = { workspace }\\n\\nObservers.observeTag(\\n\\t\\"MyTag\\",\\n\\tfunction(instance: Instance)\\n\\t\\t...\\n\\tend,\\n\\tallowedAncestors\\n)\\n```","params":[{"name":"tag","desc":"","lua_type":"string"},{"name":"callback","desc":"","lua_type":"(instance: T) -> () -> ()"},{"name":"ancestors","desc":"","lua_type":"{ Instance }?"}],"returns":[{"desc":"","lua_type":"() -> ()\\n"}],"function_type":"static","source":{"line":56,"path":"lib/observeTag.lua"}},{"name":"observePlayer","desc":"Creates an observer that captures each player in the game.\\n\\n```lua\\nobservePlayer(function(player)\\n\\tprint(\\"Player entered game\\", player.Name)\\n\\n\\treturn function()\\n\\t\\t-- Cleanup\\n\\t\\tprint(\\"Player left game (or observer stopped)\\", player.Name)\\n\\tend\\nend)\\n```","params":[{"name":"callback","desc":"","lua_type":"(player: Player) -> (() -> ())?"}],"returns":[{"desc":"","lua_type":"() -> ()\\n"}],"function_type":"static","source":{"line":21,"path":"lib/observePlayer.lua"}}],"properties":[],"types":[],"name":"Observers","desc":"A collection of observer utility functions.","source":{"line":8,"path":"lib/init.lua"}}')}}]);