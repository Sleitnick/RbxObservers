"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[493],{769:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"observer-pattern","title":"Observer Pattern","description":"The observer pattern centers around observing the lifetime of a given state.","source":"@site/docs/observer-pattern.md","sourceDirName":".","slug":"/observer-pattern","permalink":"/RbxObservers/docs/observer-pattern","draft":false,"unlisted":false,"editUrl":"https://github.com/Sleitnick/RbxObservers/edit/main/docs/observer-pattern.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"defaultSidebar","previous":{"title":"Getting Started","permalink":"/RbxObservers/docs/intro"},"next":{"title":"Attributes","permalink":"/RbxObservers/docs/Observers/attributes"}}');var i=t(4848),o=t(8453);const s={sidebar_position:2},a="Observer Pattern",c={},l=[{value:"Why Lifetime is Important",id:"why-lifetime-is-important",level:2},{value:"Differences from Event-Driven Programming",id:"differences-from-event-driven-programming",level:2},{value:"Differences from Reactive (RX) Programming",id:"differences-from-reactive-rx-programming",level:2},{value:"Cleanup Idempotence",id:"cleanup-idempotence",level:2}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"observer-pattern",children:"Observer Pattern"})}),"\n",(0,i.jsxs)(n.p,{children:["The observer pattern centers around ",(0,i.jsx)(n.em,{children:"observing"})," the lifetime of a given state."]}),"\n",(0,i.jsxs)(n.p,{children:['The "state" in question can be anything. It could be a color value, a position, a table, or anything else. Typically, current state can be grabbed immediately (e.g. ',(0,i.jsx)(n.code,{children:"part.Color"}),"), and further changes can be detected via some sort of signal (e.g. ",(0,i.jsx)(n.code,{children:'part:GetPropertyChangedSignal("Color")'}),")."]}),"\n",(0,i.jsx)(n.p,{children:"The observer pattern should provide two crucial elements:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Detect the current and all future changes to some state."}),"\n",(0,i.jsx)(n.li,{children:"For a given observation, detect when that state changes to something else, thus to provide a way to clean up."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The general layout of an observer should look like such:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local stopObserving = observeSomething(...params, function(state)\n\t-- Do something with "state". This runs every time state changes, including the initial state.\n\n\treturn function()\n\t\t-- Cleanup. Called once "state" changes to something else, or the `stopObserving` function is called.\n\tend\nend)\n\n-- At anytime, the `stopObserving` function can be called to stop the above observer and clean up\n-- and currently-existing observations:\nstopObserving()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"why-lifetime-is-important",children:"Why Lifetime is Important"}),"\n",(0,i.jsx)(n.p,{children:"The lifetime of a state is defined by the time in which is begins to the time in which it ends. This is why the observer function requires developers to return a function for cleanup. By doing so, the lifetime of a given state can be captured. For game programming, this allows developers to kick off tasks for a given task, and then easily clean up those tasks once the state has changed."}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'observeTag("Disco", function(part)\n\t-- Start flashing the part random colors every frame:\n\tlocal heartbeat = RunService.Heartbeat:Connect(function()\n\t\tpart.Color = Color3.new(math.random(), math.random(), math.random())\n\tend)\n\n\t-- Stop flashing on cleanup:\n\treturn function()\n\t\theartbeat:Disconnect()\n\tend\nend)\n'})}),"\n",(0,i.jsxs)(n.p,{children:['In the above example, the "Disco" tag is being observed. When the observer triggers the function, we enter the beginning of the lifecycle for ',(0,i.jsx)(n.code,{children:"part"}),", where we know that ",(0,i.jsx)(n.code,{children:"part"}),' has the "Disco" tag. At this point, we can hook up our disco part by flashing it different colors every frame. Then we return a cleanup function, which will be called at the end of the lifecycle (i.e. when the Disco tag is removed or the part is destroyed). This function disconnects the heartbeat connection, thus cleaning up the operation.']}),"\n",(0,i.jsx)(n.h2,{id:"differences-from-event-driven-programming",children:"Differences from Event-Driven Programming"}),"\n",(0,i.jsxs)(n.p,{children:["Event-driven programming is quite similar, as we are able to observe changes to state. The key differences though is that event-driven programming does not necessarily encapsulate detecting the ",(0,i.jsx)(n.em,{children:"lifetime"})," of a given state, nor does it necessarily capture the ",(0,i.jsx)(n.em,{children:"current"})," state."]}),"\n",(0,i.jsx)(n.p,{children:"For instance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'part:GetPropertyChangedSignal("Color"):Connect(function() ... end)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The code above will fire any time the ",(0,i.jsx)(n.code,{children:"Color"})," property changes for ",(0,i.jsx)(n.code,{children:"part"}),". However, the triggered function has no understanding of when the given color changes again. Also, the given function will ",(0,i.jsx)(n.em,{children:"not"})," be triggered for the current state; only future changes will trigger the function."]}),"\n",(0,i.jsx)(n.h2,{id:"differences-from-reactive-rx-programming",children:"Differences from Reactive (RX) Programming"}),"\n",(0,i.jsx)(n.p,{children:"Reactive programming cares about reacting, transforming, and consuming state. While the observer pattern is quite similar, reactive programming doesn't define the lifetime of a given state."}),"\n",(0,i.jsx)(n.h2,{id:"cleanup-idempotence",children:"Cleanup Idempotence"}),"\n",(0,i.jsx)(n.p,{children:"All cleanup functions should be idempotent. In other words, cleanup functions should be capable of being called many times without causing issues. For example, the top-level cleanup for an observer could be called multiple times, but should never cause a problem. This creates a safe environment for cleanup operations."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(6540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);