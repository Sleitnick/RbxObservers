[{"title":"Getting Started","type":0,"sectionRef":"#","url":"/RbxObservers/docs/intro","content":"","keywords":""},{"title":"Wally Configuration​","type":1,"pageTitle":"Getting Started","url":"/RbxObservers/docs/intro#wally-configuration","content":"Once Wally is installed, run wally init on your project directory, and then add the various utility modules found here as dependencies. For example, the following could be a wally.toml file for a project that includes a few of these modules: [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] Signal = &quot;sleitnick/observers@^1&quot;  To install, run wally install within your project. Wally will create a Package folder in your directory with the installed dependency. "},{"title":"Rojo Configuration​","type":1,"pageTitle":"Getting Started","url":"/RbxObservers/docs/intro#rojo-configuration","content":"The Package folder created by Wally should be synced into Roblox Studio through your Rojo configuration. For instance, a Rojo configuration might have the following entry to sync the Packages folder into ReplicatedStorage: { &quot;name&quot;: &quot;rbx-util-example&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;Packages&quot;: { &quot;$path&quot;: &quot;Packages&quot; } } } }  "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"/RbxObservers/docs/intro#usage-example","content":"The Observers module can now be used in scripts, such as the following: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Observers = require(ReplicatedStorage.Packages.Observers) Observers.observeTag(&quot;SomeTag&quot;, function(instance: Instance) print(`Observing {instance}`) return function() print(`Stopped observing {instance}`) end end)  "},{"title":"Observer Pattern","type":0,"sectionRef":"#","url":"/RbxObservers/docs/observer-pattern","content":"","keywords":""},{"title":"Why Lifetime is Important​","type":1,"pageTitle":"Observer Pattern","url":"/RbxObservers/docs/observer-pattern#why-lifetime-is-important","content":"The lifetime of a state is defined by the time in which is begins to the time in which it ends. This is why the observer function requires developers to return a function for cleanup. By doing so, the lifetime of a given state can be captured. For game programming, this allows developers to kick off tasks for a given task, and then easily clean up those tasks once the state has changed. For example: observeTag(&quot;Disco&quot;, function(part) -- Start flashing the part random colors every frame: local heartbeat = RunService.Heartbeat:Connect(function() part.Color = Color3.new(math.random(), math.random(), math.random()) end) -- Stop flashing on cleanup: return function() heartbeat:Disconnect() end end)  In the above example, the &quot;Disco&quot; tag is being observed. When the observer triggers the function, we enter the beginning of the lifecycle for part, where we know that part has the &quot;Disco&quot; tag. At this point, we can hook up our disco part by flashing it different colors every frame. Then we return a cleanup function, which will be called at the end of the lifecycle (i.e. when the Disco tag is removed or the part is destroyed). This function disconnects the heartbeat connection, thus cleaning up the operation. "},{"title":"Differences from Event-Driven Programming​","type":1,"pageTitle":"Observer Pattern","url":"/RbxObservers/docs/observer-pattern#differences-from-event-driven-programming","content":"Event-driven programming is quite similar, as we are able to observe changes to state. The key differences though is that event-driven programming does not necessarily encapsulate detecting the lifetime of a given state, nor does it necessarily capture the current state. For instance: part:GetPropertyChangedSignal(&quot;Color&quot;):Connect(function() ... end)  The code above will fire any time the Color property changes for part. However, the triggered function has no understanding of when the given color changes again. Also, the given function will not be triggered for the current state; only future changes will trigger the function. "},{"title":"Differences from Reactive (RX) Programming​","type":1,"pageTitle":"Observer Pattern","url":"/RbxObservers/docs/observer-pattern#differences-from-reactive-rx-programming","content":"Reactive programming cares about reacting, transforming, and consuming state. While the observer pattern is quite similar, reactive programming doesn't define the lifetime of a given state. "},{"title":"Observers","type":0,"sectionRef":"#","url":"/RbxObservers/api/Observers","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#functions","content":" "},{"title":"observeTag​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#observeTag","content":"&lt;/&gt; Observers.observeTag( tag: string, callback: (instance: T) → () → (), ancestors: {Instance }? ) → () → () Creates an observer around a CollectionService tag. The given callback will fire for each instance that has the given tag. The callback should return a function, which will be called when the given instance's tag is either destroyed, loses the given tag, or (if the ancestors table is provided) goes outside of the allowed ancestors. The function itself returns a function that can be called to stop the observer. This will also call any cleanup functions of currently-observed instances. local stopObserver = Observers.observeTag(&quot;MyTag&quot;, function(instance: Instance) print(&quot;Observing&quot;, instance) -- The &quot;cleanup&quot; function: return function() print(&quot;Stopped observing&quot;, instance) end end) -- Optionally, the `stopObserver` function can be called to completely stop the observer: task.wait(10) stopObserver() Ancestor Inclusion List By default, the observeTag function will observe a tagged instance anywhere in the Roblox game hierarchy. The ancestors table can optionally be used, which will restrict the observer to only observe tagged instances that are descendants of instances within the ancestors table. For instance, if a tagged instance should only be observed when it is in the Workspace, the Workspace can be added to the ancestors list. This might be useful if a tagged model prefab exist somewhere such as ServerStorage, but shouldn't be observed until placed into the Workspace. local allowedAncestors = { workspace } Observers.observeTag( &quot;MyTag&quot;, function(instance: Instance) ... end, allowedAncestors )   "},{"title":"observeAttribute​","type":1,"pageTitle":"Observers","url":"/RbxObservers/api/Observers#observeAttribute","content":"&lt;/&gt; Observers.observeAttribute( instance: Instance , name: string, callback: (value: T) → () → () ) → () → () Creates an observer around an attribute of a given instance. The callback will fire for any non-nil attribute value. observeAttribute(workspace.Model, &quot;MyAttribute&quot;, function(value) print(&quot;MyAttribute is now:&quot;, value) return function() -- Cleanup print(&quot;MyAttribute is no longer:&quot;, value) end end) The observer also returns a function that can be called to clean up the observer: local stopObserving = observeAttribute(workspace.Model, &quot;MyAttribute&quot;, function(value) ... end) task.wait(10) stopObserving()  "}]